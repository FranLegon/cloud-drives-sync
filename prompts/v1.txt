I have multiple Google accounts and a couple Microsoft accounts and want to sync storage (Google Drive and One Drive) accross them all. I made a GCP Web Application (named GoogleBackuper-OAuthClientID-WebClient) and an Azure Enterprise Application (named OneDrive-Application) and gave them the necesary delegated permisions over drive services to achieve this programatically. These applications will only be used by me and will never be released to a production environment.

I want a golang binary that does different things according to flag passed:
- Flag "getMetadata": Using all accounts (refresh tokens) it has, inserts or updates all files information into a table in an sqlite db in the same folder/directory the binary is running (use Credentials_SQLite.json.enc). The information should include Provider (Microsft/Google), Owner (email of owner user), FileHash, FileId (internal Google Drive or OneDrive id), FileName, FileSize, FileExtension, ParentFolderName, ParentFolderID (internal Google Drive or OneDrive id), CreatedOn (Google Drive or OneDrive metadata, not db metadata) and LastModified. 
- Flag "checkForDuplicates": runs the same as "getMetadata" to then query the table looking for repeated hashes in a single provider (duplicates accross providers are ignored)
- Flag "removeDuplicates": runs the same as "checkForDuplicates" and prompts the user to choose which version of each duplicate to delete.
- Flag "removeDuplicatesUnsafe": which deletes all duplicates automatically leaving only the one with the oldest CreatedOn value.
- Flag "addAccount": asks if you want to add a Microsoft or Google account and generates a http://localhost:8080 redirect uri where the user must be logged-in to retrieve the code and generate the refresh token. Stores the refresh token in Credentials_UsersRefreshTokens.json.enc
- Flag "mantainRefreshTokens": checks if all refresh tokens in Credentials_UsersRefreshTokens.json.enc are still valid and if it finds one or more that aren't, asks for it to be reloged-in. 
- Flag "shareEverythingWithMain": there will be a single main google account and a single main microsoft account specified in Credentials_UsersRefreshTokens.json by bool propery "isMain". This flag shares every file and folder in every account with the main accounts given them max priviledges possible (editor) but not transfering ownership. This should be done automatically whenever any process of any flag creates a file or folder, the flag will only be useful for files/folders not created using the goglang binary, since those should already be shared. 
- Flag "syncProviders": This flag will make sure every file in google drive is in onedrive and vicebersa. If a hash is in one provider and not in another, it must be created where it's missing. The folders schema/structure must also be preserved, move everything until its the same for both providers.
- Flag "neverFull": This flag will make sure no account is more than 95% full. If one is, some files will be transfered from one account to another with more free space.
- Flag "safe": This flag can be used in combination with any other flag and makes sure no writes, deletes or modifications are made in GoogleDrive or OneDrive, but rather its just displayed to the user what would've been created/deleted/modified. Altering the local sql db is allowed and readonly operations over cloud drives are also allowed.
- Flag "help": Lists all flags and information on what they do. If the binary is run with no flags, it should default to this flag.
- Flag "innit": if sqlite db doesn't exist, ask in terminal for username/password and create it where the binary is located. Also create a Credentials_SQLite.json.enc in the same dir so that the process doesnt need to ask for credentials when it needs to use the db. Create any necessary tables. Then, if Credentials_UsersRefreshTokens.json doesnt already have a main account specified for each provider (bool propery "isMain"), ask for these and set them up. 

As you can see, we only distingih providers and main or backup accounts, but there's no priority or difference between backup accounts for the same provider. To choose which one to use in each decision, just check if the account has enough free space for the action about to take place. Main accounts should never own any file, only folders, but must have edit access to everything. 

All client credentials (client ID, client secret, redirect uri) should be stored in Credentials_CloudProviderApplications.json.enc. All credentials jsons (Credentials_SQLite.json, Credentials_UsersRefreshTokens.json and Credentials_CloudProviderApplications.json) will be encrypted and decrypted using a symetric key embedded in the binary (if possible, generated at compile time. If not possible, just hardcode it).

I only used the sqlite db to store files metadata, but feel free to create other tables if you can think of other useful information to store. All db operations should use interfaces so that i can swap sqlite for some other RDBMS (like SQL Server or PostgreSQL) in the future if I want to.

For files downloads and uploads, use streaming whenever possible to avoid loading entire files into memory.

